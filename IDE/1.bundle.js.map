{"version":3,"sources":["webpack:////home/elliott/playground/test/theia/packages/filesystem/src/common/filesystem-watcher-protocol.ts","webpack:////home/elliott/playground/test/theia/packages/filesystem/src/common/filesystem.ts"],"names":[],"mappings":"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","file":"1.bundle.js","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { injectable, inject } from 'inversify';\nimport { JsonRpcServer, JsonRpcProxy } from '@theia/core';\n\nexport const fileSystemWatcherPath = '/services/fs-watcher';\n\nexport const FileSystemWatcherServer = Symbol('FileSystemWatcherServer');\nexport interface FileSystemWatcherServer extends JsonRpcServer<FileSystemWatcherClient> {\n    /**\n     * Start file watching for the given param.\n     * Resolve when watching is started.\n     * Return a watcher id.\n     */\n    watchFileChanges(uri: string, options?: WatchOptions): Promise<number>;\n\n    /**\n     * Stop file watching for the given id.\n     * Resolve when watching is stopped.\n     */\n    unwatchFileChanges(watcher: number): Promise<void>;\n\n}\n\nexport interface FileSystemWatcherClient {\n    /**\n     * Notify when files under watched uris are changed.\n     */\n    onDidFilesChanged(event: DidFilesChangedParams): void;\n}\n\nexport interface WatchOptions {\n    ignored: string[];\n}\n\nexport interface DidFilesChangedParams {\n    changes: FileChange[];\n}\n\nexport interface FileChange {\n    uri: string;\n    type: FileChangeType;\n}\n\nexport enum FileChangeType {\n    UPDATED = 0,\n    ADDED = 1,\n    DELETED = 2\n}\n\nexport const FileSystemWatcherServerProxy = Symbol('FileSystemWatcherServerProxy');\nexport type FileSystemWatcherServerProxy = JsonRpcProxy<FileSystemWatcherServer>;\n\n@injectable()\nexport class ReconnectingFileSystemWatcherServer implements FileSystemWatcherServer {\n\n    protected watcherSequence = 1;\n    protected readonly watchParams = new Map<number, {\n        uri: string;\n        options?: WatchOptions\n    }>();\n    protected readonly localToRemoteWatcher = new Map<number, number>();\n\n    constructor(\n        @inject(FileSystemWatcherServerProxy) protected readonly proxy: FileSystemWatcherServerProxy\n    ) {\n        const onInitialized = this.proxy.onDidOpenConnection(() => {\n            // skip reconnection on the first connection\n            onInitialized.dispose();\n            this.proxy.onDidOpenConnection(() => this.reconnect());\n        });\n    }\n\n    protected reconnect(): void {\n        for (const [watcher, { uri, options }] of this.watchParams.entries()) {\n            this.doWatchFileChanges(watcher, uri, options);\n        }\n    }\n\n    dispose(): void {\n        this.proxy.dispose();\n    }\n\n    watchFileChanges(uri: string, options?: WatchOptions): Promise<number> {\n        const watcher = this.watcherSequence++;\n        this.watchParams.set(watcher, { uri, options });\n        return this.doWatchFileChanges(watcher, uri, options);\n    }\n\n    protected doWatchFileChanges(watcher: number, uri: string, options?: WatchOptions): Promise<number> {\n        return this.proxy.watchFileChanges(uri, options).then(remote => {\n            this.localToRemoteWatcher.set(watcher, remote);\n            return watcher;\n        });\n    }\n\n    unwatchFileChanges(watcher: number): Promise<void> {\n        this.watchParams.delete(watcher);\n        const remote = this.localToRemoteWatcher.get(watcher);\n        if (remote) {\n            this.localToRemoteWatcher.delete(watcher);\n            return this.proxy.unwatchFileChanges(remote);\n        }\n        return Promise.resolve();\n    }\n\n    setClient(client: FileSystemWatcherClient | undefined): void {\n        this.proxy.setClient(client);\n    }\n\n}\n","/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { TextDocumentContentChangeEvent } from 'vscode-languageserver-protocol';\nimport { JsonRpcServer, ApplicationError } from '@theia/core/lib/common';\nimport { injectable } from 'inversify';\nexport const fileSystemPath = '/services/filesystem';\n\nexport const FileSystem = Symbol('FileSystem');\n\nexport interface FileSystem extends JsonRpcServer<FileSystemClient> {\n\n    /**\n     * Returns the file stat for the given URI.\n     *\n     * If the uri points to a folder it will contain one level of unresolved children.\n     *\n     * `undefined` if a file for the given URI does not exist.\n     */\n    getFileStat(uri: string): Promise<FileStat | undefined>;\n\n    /**\n     * Finds out if a file identified by the resource exists.\n     */\n    exists(uri: string): Promise<boolean>;\n\n    /**\n     * Resolve the contents of a file identified by the resource.\n     */\n    resolveContent(uri: string, options?: { encoding?: string }): Promise<{ stat: FileStat, content: string }>;\n\n    /**\n     * Updates the content replacing its previous value.\n     */\n    setContent(file: FileStat, content: string, options?: { encoding?: string }): Promise<FileStat>;\n\n    /**\n     * Updates the content replacing its previous value.\n     *\n     * The optional parameter `overwriteEncoding` can be used to transform the encoding of a file.\n     *\n     * |   | encoding | overwriteEncoding | behaviour |\n     * |---|----------|-------------------|-----------|\n     * | 1 | undefined |    undefined     | read & write file in default encoding |\n     * | 2 | undefined |        ✓         | read file in default encoding; write file in `overwriteEncoding` |\n     * | 3 |     ✓    |     undefined     | read & write file in `encoding` |\n     * | 4 |     ✓    |        ✓         | read file in `encoding`; write file in `overwriteEncoding` |\n     */\n    updateContent(file: FileStat, contentChanges: TextDocumentContentChangeEvent[], options?: { encoding?: string, overwriteEncoding?: string }): Promise<FileStat>;\n\n    /**\n     * Moves the file to a new path identified by the resource.\n     *\n     * The optional parameter overwrite can be set to replace an existing file at the location.\n     *\n     * |           | missing | file | empty dir |    dir    |\n     * |-----------|---------|------|-----------|-----------|\n     * | missing   |    x    |   x  |     x     |     x     |\n     * | file      |    ✓    |   x  |     x     |     x     |\n     * | empty dir |    ✓    |   x  |     x     | overwrite |\n     * | dir       |    ✓    |   x  | overwrite | overwrite |\n     *\n     */\n    move(sourceUri: string, targetUri: string, options?: FileMoveOptions): Promise<FileStat>;\n\n    /**\n     * Copies the file to a path identified by the resource.\n     *\n     * The optional parameter overwrite can be set to replace an existing file at the location.\n     */\n    copy(sourceUri: string, targetUri: string, options?: { overwrite?: boolean, recursive?: boolean }): Promise<FileStat>;\n\n    /**\n     * Creates a new file with the given path. The returned promise\n     * will have the stat model object as a result.\n     *\n     * The optional parameter content can be used as value to fill into the new file.\n     */\n    createFile(uri: string, options?: { content?: string, encoding?: string }): Promise<FileStat>;\n\n    /**\n     * Creates a new folder with the given path. The returned promise\n     * will have the stat model object as a result.\n     */\n    createFolder(uri: string): Promise<FileStat>;\n\n    /**\n     * Creates a new empty file if the given path does not exist and otherwise\n     * will set the mtime and atime of the file to the current date.\n     */\n    touchFile(uri: string): Promise<FileStat>;\n\n    /**\n     * Deletes the provided file. The optional moveToTrash parameter allows to\n     * move the file to trash.\n     */\n    delete(uri: string, options?: FileDeleteOptions): Promise<void>;\n\n    /**\n     * Returns the encoding of the given file resource.\n     */\n    getEncoding(uri: string): Promise<string>;\n\n    /**\n     * Guess encoding of a given file based on its content.\n     */\n    guessEncoding(uri: string): Promise<string | undefined>;\n\n    /**\n     * Return list of available roots.\n     */\n    getRoots(): Promise<FileStat[]>;\n\n    /**\n     * Returns a promise that resolves to a file stat representing the current user's home directory.\n     */\n    getCurrentUserHome(): Promise<FileStat | undefined>;\n\n    /**\n     * Resolves to an array of URIs pointing to the available drives on the filesystem.\n     */\n    getDrives(): Promise<string[]>;\n\n    /**\n     * Tests a user's permissions for the file or directory specified by URI.\n     * The mode argument is an optional integer that specifies the accessibility checks to be performed.\n     * Check `FileAccess.Constants` for possible values of mode.\n     * It is possible to create a mask consisting of the bitwise `OR` of two or more values (e.g. FileAccess.Constants.W_OK | FileAccess.Constants.R_OK).\n     * If `mode` is not defined, `FileAccess.Constants.F_OK` will be used instead.\n     */\n    access(uri: string, mode?: number): Promise<boolean>\n\n    /**\n     * Returns the path of the given file URI, specific to the backend's operating system.\n     * If the URI is not a file URI, undefined is returned.\n     *\n     * USE WITH CAUTION: You should always prefer URIs to paths if possible, as they are\n     * portable and platform independent. Paths should only be used in cases you directly\n     * interact with the OS, e.g. when running a command on the shell.\n     */\n    getFsPath(uri: string): Promise<string | undefined>\n\n}\n\nexport namespace FileAccess {\n\n    export namespace Constants {\n\n        /**\n         * Flag indicating that the file is visible to the calling process.\n         * This is useful for determining if a file exists, but says nothing about rwx permissions. Default if no mode is specified.\n         */\n        export const F_OK: number = 0;\n\n        /**\n         * Flag indicating that the file can be read by the calling process.\n         */\n        export const R_OK: number = 4;\n\n        /**\n         * Flag indicating that the file can be written by the calling process.\n         */\n        export const W_OK: number = 2;\n\n        /**\n         * Flag indicating that the file can be executed by the calling process.\n         * This has no effect on Windows (will behave like `FileAccess.F_OK`).\n         */\n        export const X_OK: number = 1;\n\n    }\n\n}\n\nexport interface FileMoveOptions {\n    overwrite?: boolean;\n}\n\nexport interface FileDeleteOptions {\n    moveToTrash?: boolean\n}\n\n/**\n * A callback type, called when we try to save a file but realize it has been\n * modified by somebody else since we have opened it.  `originalStat` is the\n * stat at the moment we opened the file, `currentStat` is the stat at the\n * moment we try to save it (after the external modification).  The callback\n * should return true if we still want to save the file, false otherwise.\n */\nexport const FileShouldOverwrite = Symbol('FileShouldOverwrite');\nexport interface FileShouldOverwrite {\n    (originalStat: FileStat, currentStat: FileStat): Promise<boolean>;\n}\n\nexport interface FileSystemClient {\n\n    /**\n     * Tests whether the given file can be overwritten\n     * in the case if it is out of sync with the given file stat.\n     */\n    shouldOverwrite: FileShouldOverwrite;\n\n    willDelete(uri: string): Promise<void>;\n\n    didDelete(uri: string, failed: boolean): Promise<void>;\n\n    willMove(sourceUri: string, targetUri: string): Promise<void>;\n\n    didMove(sourceUri: string, targetUri: string, failed: boolean): Promise<void>;\n}\n\n@injectable()\nexport class DispatchingFileSystemClient implements FileSystemClient {\n\n    readonly clients = new Set<FileSystemClient>();\n\n    shouldOverwrite(originalStat: FileStat, currentStat: FileStat): Promise<boolean> {\n        return Promise.race([...this.clients].map(client =>\n            client.shouldOverwrite(originalStat, currentStat))\n        );\n    }\n\n    async willDelete(uri: string): Promise<void> {\n        await Promise.all([...this.clients].map(client => client.willDelete(uri)));\n    }\n\n    async didDelete(uri: string, failed: boolean): Promise<void> {\n        await Promise.all([...this.clients].map(client => client.didDelete(uri, failed)));\n    }\n\n    async willMove(sourceUri: string, targetUri: string): Promise<void> {\n        await Promise.all([...this.clients].map(client => client.willMove(sourceUri, targetUri)));\n    }\n\n    async didMove(sourceUri: string, targetUri: string, failed: boolean): Promise<void> {\n        await Promise.all([...this.clients].map(client => client.didMove(sourceUri, targetUri, failed)));\n    }\n\n}\n\n/**\n * A file resource with meta information.\n */\nexport interface FileStat {\n\n    /**\n     * The URI of the file.\n     */\n    uri: string;\n\n    /**\n     * The last modification of this file.\n     */\n    lastModification: number;\n\n    /**\n     * `true` if the resource is a directory. Otherwise, `false`.\n     */\n    isDirectory: boolean;\n\n    /**\n     * The children of the file stat.\n     * If it is `undefined` and `isDirectory` is `true`, then this file stat is unresolved.\n     */\n    children?: FileStat[];\n\n    /**\n     * The size of the file if known.\n     */\n    size?: number;\n\n}\n\nexport namespace FileStat {\n    export function is(candidate: Object | undefined): candidate is FileStat {\n        return typeof candidate === 'object' && ('uri' in candidate) && ('lastModification' in candidate) && ('isDirectory' in candidate);\n    }\n\n    export function equals(one: object | undefined, other: object | undefined): boolean {\n        if (!one || !other || !is(one) || !is(other)) {\n            return false;\n        }\n        return one.uri === other.uri\n            && one.lastModification === other.lastModification\n            && one.isDirectory === other.isDirectory;\n    }\n}\n\nexport namespace FileSystemError {\n    export const FileNotFound = ApplicationError.declare(-33000, (uri: string, prefix?: string) => ({\n        message: `${prefix ? prefix + ' ' : ''}'${uri}' has not been found.`,\n        data: { uri }\n    }));\n    export const FileExists = ApplicationError.declare(-33001, (uri: string, prefix?: string) => ({\n        message: `${prefix ? prefix + ' ' : ''}'${uri}' already exists.`,\n        data: { uri }\n    }));\n    export const FileIsDirectory = ApplicationError.declare(-33002, (uri: string, prefix?: string) => ({\n        message: `${prefix ? prefix + ' ' : ''}'${uri}' is a directory.`,\n        data: { uri }\n    }));\n    export const FileNotDirectory = ApplicationError.declare(-33003, (uri: string, prefix?: string) => ({\n        message: `${prefix ? prefix + ' ' : ''}'${uri}' is not a directory.`,\n        data: { uri }\n    }));\n    export const FileIsOutOfSync = ApplicationError.declare(-33004, (file: FileStat, stat: FileStat) => ({\n        message: `'${file.uri}' is out of sync.`,\n        data: { file, stat }\n    }));\n}\n"],"sourceRoot":""}